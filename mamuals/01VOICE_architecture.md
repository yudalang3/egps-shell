# VOICE 模块架构指南

**VOICE** = **V**ersatile **O**pen **I**nput **C**lick **E**xecute

用于在 eGPS 2.1+ 中快速开发适合`生物数据分析`的图形界面模块（同时兼顾三种使用方式：命令行、脚本化、图形界面）。

**开发者API对应的包名**：`egps2.builtin.modules.voice`

---

## 1. VOICE 解决什么问题

VOICE 统一了这类工具模块的“常见外壳”，你只需要：
- 定义参数（默认值 + 提示 + 分组/高级区）
- 实现执行逻辑（把参数解析后交给你的业务代码）

框架负责提供一致的体验与基础能力：
- 文本参数输入（带校验/解析）
- 示例/模板文本生成
- 书签（参数预设）的保存/加载/管理
- 统一按钮与事件处理（执行、重置、帮助等）
- 可选的控制台输出（标签页类模块）
- 可选的命令行入口（用于批处理/无界面执行）

---

## 2. 总体架构（分层）

VOICE 按“框架外壳 → 通用界面 → 参数处理 → 业务执行”分层：

1) **框架层（3 种集成形态）**：决定模块以何种方式嵌入/展示（浮动窗、主窗口标签页、可停靠子标签页）。  
2) **核心界面层**：标准布局（左书签树 + 右输入区 + 操作按钮；标签页模式可带底部控制台）。  
3) **参数处理层**：把“文本参数”解析成结构化数据，提供类型安全的读取方式。  
4) **执行层**：你的模块逻辑（计算、文件处理、调用其它库等）。

---

### 标准界面布局

所有 VOICE 模块都遵循这套标准布局（以“标签页形态”为例）：

```
┌─────────────────────────────────────────────────────────┐
│  VOICE Module Window/Panel                              │
│  ┌───────────────────┬───────────────────────────────┐  │
│  │                   │                               │  │
│  │  Bookmark Tree    │   Input Area                  │  │
│  │  (Left Panel)     │   ┌─────────────────────────┐ │  │
│  │                   │   │ #Example1               │ │  │
│  │  • Category A     │   │ param1: value1          │ │  │
│  │    ├─ Preset 1    │   │ param2: value2          │ │  │
│  │    └─ Preset 2    │   │ ...                     │ │  │
│  │  • Category B     │   └─────────────────────────┘ │  │
│  │    └─ Preset 3    │   ──────────────────────────  │  │
│  │                   │   Bookmark Operations         │  │
│  │                   │   [Save] [Load] [Delete] ...  │  │
│  │                   │   ──────────────────────────  │  │
│  │                   │   [Execute] [Reset] [Help]    │  │
│  └───────────────────┴───────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────┐  │
│  │  Console Output (Optional, Tab modules only)      │  │
│  │  > Executing...                                   │  │
│  │  > Result: Success                                │  │
│  └───────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

---

## 3. 三种使用框架（最重要的选择）

VOICE 提供 3 个基类，对应 3 种使用场景：

### A. 浮动窗框架（JDialog）
- **基类**：`AbstractGuiBaseVoiceFeaturedPanel`
- **适用**：独立小工具、轻量操作、无需控制台输出
- **特点**：实现快、与主框架耦合低

### B. 主窗口标签页框架（完整模块）
- **基类**：`TabModuleFaceOfVoice`
- **适用**：需要长期驻留、需要大量输出/日志的工具
- **特点**：完整接入 eGPS 模块体系（更“正式”的模块形态），通常可输出到下方控制台

### C. 可停靠子标签页框架（工具集合中的子工具，设分步骤的生物数据分析）
- **基类**：`DockableTabModuleFaceOfVoice`
- **适用**：一组相关小工具打包在同一个父模块中
- **特点**：与父模块共享基础设施（例如控制台），更适合“工具箱/面板”式组织

**快速判断**：
- 快速执行的小工具 → 选“主窗口标签页框架”  
- 需要有可视化呈现的模块 → 选“浮动窗框架”  
- 完整多步骤的分析流程 → 选“可停靠子标签页框架”

---
两个主流需求量大的模块开发场景：

#### 1. 比较基因组学：基因家族聚类分析


一般我们的步骤如下：

1. 鉴定同源基因
2. 创建多序列联配MSA
3. 构建进化树
4. 进化树美工

首先可以编写C类模块 "同源基因鉴定” ，里面包括子标签：1. blast search，里面可以配置子模块，调用blast运行 2. hummer search，里面可以配置，调用hummer运行
3. filter results, 4. rename sequences

然后创建 B类模块，例如名为 "MAFFT wrapper，内部调用 MAFFT进行多序列联配"，执行之后可以设置参数将结果保存到本地目录，也可以跳转到 Alignment view模块

接着编写A类模块 "Alignment view"，里面可以配置参数。用户可以直接使用 Floating Dialog导入数据与参数，或者直接接收数据展示。

然后创建B类模块 "Tree Builder from MSA"，里面可以配置参数。用户从上一步得到的结果构建进化树。

最后创建A类模块 "Tree View"，里面可以配置参数。用户可以直接使用 Floating Dialog导入数据与参数，或者直接接收数据展示。用户即可进行美工。

#### 2. 转录组学：鉴定差异表达基因和富集分析

一般我们的步骤如下：

1. 数据上游定量，得到基因表达矩阵
2. 调用你第三方库鉴定差异表达基因
3. 富集分析
4. 可视化美工

可以先创建A类模块：火山图，MA Plot，条形图

然后编写若干个B类模块，跳转到上面的模块。

或者干脆做一个整合的C类模块，里面以子Tab的形式显式聚合分析流程。

---

### eGPS 代码库示例

建议直接阅读这些真实的 VOICE 模块实现：

更多示例可参考： https://github.com/yudalang3/egps-shell/tree/main/module_dev_references/voice/demo

1. **便捷工具示例**（`demo.handytools`）
    - 复杂的多分组参数
    - 使用“可停靠子标签页框架”组织多个子标签页

2. **浮动窗示例**（`demo.floating`）
    - 简单的独立小工具
    - `AbstractGuiBaseVoiceFeaturedPanel` 的典型用法

3. **可停靠子标签页示例**（`demo.dockable`）
    - 一个父模块包含多个 VOICE 子标签页
    - 展示如何组织“工具集合/工具箱”



---

## 4. 参数文本与解析（核心工作流）

### 4.1 你定义参数
通过 `AbstractParamsAssignerAndParser4VOICE` 声明参数（键、默认值、提示），框架可据此生成示例文本并驱动校验。

### 4.2 用户输入参数（文本）
常见规则（精要）：
- `#` 开头为注释行（忽略）
- 支持 `键: 值` 或 `键=值`
- 空行忽略；重复键通常“后者覆盖前者”

### 4.3 特殊标记（用于组织复杂参数）
- `%1`、`%2`、`%3`…：参数分组/分类标题（让输入更易读）
- `^`：高级参数区（图形界面中通常默认折叠）
- `@`：保留字段（一般不常用）

### 4.4 你在执行阶段取参数
解析后通过 `OrganizedParameterGetter` 获取参数（字符串、int、double、boolean、列表等），避免手写解析与类型转换。

---

## 5. 使用 VOICE 的好处（更贴近日常开发）

VOICE 的价值不只是“做出一个界面”，而是把模块开发中最重复、最容易出错的部分收敛到统一框架里，让你更专注在业务逻辑本身：
- **开发效率更高**：参数定义、示例文本、解析与校验、按钮与事件流程等都有统一套路，减少重复造轮子。
- **用户学习成本更低**：不同模块的交互一致（输入区、示例、书签、执行），用户迁移成本低，上手更快。
- **更利于复现实验/流程**：参数文本天然可保存、可复制、可版本化；配合书签更容易沉淀常用配置。
- **更容易做批处理与自动化**：同一套“参数驱动”的思路既能跑图形界面，也能走命令行/脚本，便于接入流水线。

---


## 6. 命令行/批处理（可选）

部分 VOICE 模块可提供命令行运行入口（例如实现 `SubTabModuleRunner`），典型用途：
- 不打开图形界面，直接读取参数文件并执行
- 批量跑任务、接入脚本流水线

让你的 VOICE 模块支持从命令行执行：

```java
public class MyModule extends TabModuleFaceOfVoice implements SubTabModuleRunner {

    @Override
    public void runFromCommandLine(String[] args) throws Exception {
        // args[0] = 参数文件路径
        String paramText = Files.readString(Paths.get(args[0]));
        OrganizedParameterGetter params = mapProducer.getParameterParser()
            .getOrganizedParameterGetter(paramText);
        executeLogic(params);
    }
}
```

**用法**：
```bash
java -cp "..." egps2.builtin.modules.CLI com.myproject.MyModule params.txt
```



---


## 问答

1. **问**：支持自定义控件吗？

**答**：可以做到，但不太推荐。需要先想清楚你为什么要用 `VOICE` 框架：如果大量依赖自定义控件，往往意味着你已经偏离了 VOICE 的被创造的目的。此时更合适的做法是跳出 VOICE 框架，从零搭建更贴合你需求的图形界面。

2. **问**：VOICE 适合做什么类型的应用/模块？

**答**：只要你的模块可以抽象成“给定一段结构化参数 → 执行任务 → 输出结果/日志”的模式，就很适合用 VOICE 来做。
